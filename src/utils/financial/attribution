// ===========================================
// src/utils/financial/attribution.ts
// Performance Attribution Analysis
// ===========================================

import type { Asset, Portfolio } from '../../types';
import { calculateAnnualizedReturn } from './riskMetrics';

export interface AttributionResult {
  totalReturn: number;
  benchmarkReturn: number;
  activeReturn: number;
  allocationEffect: number;
  selectionEffect: number;
  interactionEffect: number;
  sectorBreakdown: SectorAttribution[];
  securityBreakdown: SecurityAttribution[];
}

export interface SectorAttribution {
  sector: string;
  portfolioWeight: number;
  benchmarkWeight: number;
  portfolioReturn: number;
  benchmarkReturn: number;
  allocationEffect: number;
  selectionEffect: number;
  interactionEffect: number;
  totalEffect: number;
}

export interface SecurityAttribution {
  symbol: string;
  weight: number;
  return: number;
  contribution: number;
  activeWeight: number;
  activeReturn: number;
  activeContribution: number;
}

export interface StyleAttribution {
  factor: string;
  exposure: number;
  factorReturn: number;
  contribution: number;
  activeExposure?: number;
  activeContribution?: number;
}

export interface RiskAttribution {
  totalRisk: number;
  systematicRisk: number;
  specificRisk: number;
  factorRisks: FactorRisk[];
}

export interface FactorRisk {
  factor: string;
  exposure: number;
  volatility: number;
  contribution: number;
  percentage: number;
}

// ===========================================
// Brinson Attribution Model
// ===========================================

/**
 * Brinson-Hood-Beebower attribution analysis
 */
export function calculateBrinsonAttribution(
  portfolio: Portfolio,
  benchmarkWeights: { [symbol: string]: number },
  benchmarkReturns: { [symbol: string]: number[] },
  sectors: { [symbol: string]: string }
): AttributionResult {
  const portfolioReturn = calculateAnnualizedReturn(portfolio.returns);
  
  // Calculate benchmark return
  let benchmarkReturn = 0;
  for (const [symbol, weight] of Object.entries(benchmarkWeights)) {
    if (benchmarkReturns[symbol]) {
      benchmarkReturn += weight * calculateAnnualizedReturn(benchmarkReturns[symbol]);
    }
  }
  
  const activeReturn = portfolioReturn - benchmarkReturn;
  
  // Sector-level attribution
  const sectorData = aggregateBySector(portfolio, benchmarkWeights, benchmarkReturns, sectors);
  const sectorBreakdown = calculateSectorAttribution(sectorData);
  
  // Security-level attribution
  const securityBreakdown = calculateSecurityAttribution(portfolio, benchmarkWeights, benchmarkReturns);
  
  // Total effects
  const allocationEffect = sectorBreakdown.reduce((sum, s) => sum + s.allocationEffect, 0);
  const selectionEffect = sectorBreakdown.reduce((sum, s) => sum + s.selectionEffect, 0);
  const interactionEffect = sectorBreakdown.reduce((sum, s) => sum + s.interactionEffect, 0);
  
  return {
    totalReturn: portfolioReturn,
    benchmarkReturn,
    activeReturn,
    allocationEffect,
    selectionEffect,
    interactionEffect,
    sectorBreakdown,
    securityBreakdown
  };
}

/**
 * Calculate sector-level attribution effects
 */
function calculateSectorAttribution(sectorData: SectorData[]): SectorAttribution[] {
  return sectorData.map(sector => {
    // Allocation Effect = (wp - wb) × rb
    const allocationEffect = (sector.portfolioWeight - sector.benchmarkWeight) * sector.benchmarkReturn;
    
    // Selection Effect = wb × (rp - rb)
    const selectionEffect = sector.benchmarkWeight * (sector.portfolioReturn - sector.benchmarkReturn);
    
    // Interaction Effect = (wp - wb) × (rp - rb)
    const interactionEffect = (sector.portfolioWeight - sector.benchmarkWeight) * 
                             (sector.portfolioReturn - sector.benchmarkReturn);
    
    const totalEffect = allocationEffect + selectionEffect + interactionEffect;
    
    return {
      sector: sector.sector,
      portfolioWeight: sector.portfolioWeight,
      benchmarkWeight: sector.benchmarkWeight,
      portfolioReturn: sector.portfolioReturn,
      benchmarkReturn: sector.benchmarkReturn,
      allocationEffect,
      selectionEffect,
      interactionEffect,
      totalEffect
    };
  });
}

/**
 * Calculate security-level attribution
 */
function calculateSecurityAttribution(
  portfolio: Portfolio,
  benchmarkWeights: { [symbol: string]: number },
  benchmarkReturns: { [symbol: string]: number[] }
): SecurityAttribution[] {
  return portfolio.assets.map((asset, index) => {
    const weight = portfolio.weights[index];
    const assetReturn = calculateAnnualizedReturn(asset.returns);
    const contribution = weight * assetReturn;
    
    const benchmarkWeight = benchmarkWeights[asset.symbol] || 0;
    const benchmarkReturn = benchmarkReturns[asset.symbol] 
      ? calculateAnnualizedReturn(benchmarkReturns[asset.symbol]) 
      : 0;
    
    const activeWeight = weight - benchmarkWeight;
    const activeReturn = assetReturn - benchmarkReturn;
    const activeContribution = weight * activeReturn + activeWeight * benchmarkReturn;
    
    return {
      symbol: asset.symbol,
      weight,
      return: assetReturn,
      contribution,
      activeWeight,
      activeReturn,
      activeContribution
    };
  });
}

// ===========================================
// Factor Attribution
// ===========================================

/**
 * Multi-factor attribution analysis
 */
export function calculateFactorAttribution(
  portfolio: Portfolio,
  factorExposures: { [symbol: string]: { [factor: string]: number } },
  factorReturns: { [factor: string]: number[] },
  riskFreeRate: number = 0.02
): StyleAttribution[] {
  const portfolioFactorExposures = calculatePortfolioFactorExposures(portfolio, factorExposures);
  
  return Object.entries(portfolioFactorExposures).map(([factor, exposure]) => {
    const factorReturn = factorReturns[factor] 
      ? calculateAnnualizedReturn(factorReturns[factor]) - riskFreeRate
      : 0;
    
    const contribution = exposure * factorReturn;
    
    return {
      factor,
      exposure,
      factorReturn,
      contribution
    };
  });
}

/**
 * Calculate portfolio's factor exposures
 */
function calculatePortfolioFactorExposures(
  portfolio: Portfolio,
  factorExposures: { [symbol: string]: { [factor: string]: number } }
): { [factor: string]: number } {
  const portfolioExposures: { [factor: string]: number } = {};
  
  // Get all unique factors
  const allFactors = new Set<string>();
  Object.values(factorExposures).forEach(exposures => {
    Object.keys(exposures).forEach(factor => allFactors.add(factor));
  });
  
  // Calculate weighted average exposures
  allFactors.forEach(factor => {
    let totalExposure = 0;
    
    portfolio.assets.forEach((asset, index) => {
      const weight = portfolio.weights[index];
      const exposure = factorExposures[asset.symbol]?.[factor] || 0;
      totalExposure += weight * exposure;
    });
    
    portfolioExposures[factor] = totalExposure;
  });
  
  return portfolioExposures;
}

// ===========================================
// Risk Attribution
// ===========================================

/**
 * Risk attribution analysis
 */
export function calculateRiskAttribution(
  portfolio: Portfolio,
  factorLoadings: { [symbol: string]: { [factor: string]: number } },
  factorCovarianceMatrix: { [factor: string]: { [factor: string]: number } },
  specificRisks: { [symbol: string]: number }
): RiskAttribution {
  const portfolioFactorExposures = calculatePortfolioFactorExposures(portfolio, factorLoadings);
  
  // Calculate factor contributions to risk
  const factorRisks = calculateFactorRiskContributions(
    portfolioFactorExposures,
    factorCovarianceMatrix
  );
  
  // Calculate specific risk
  const specificRisk = calculateSpecificRisk(portfolio, specificRisks);
  
  // Calculate systematic risk
  const systematicRisk = Math.sqrt(factorRisks.reduce((sum, fr) => sum + Math.pow(fr.contribution, 2), 0));
  
  // Total risk
  const totalRisk = Math.sqrt(Math.pow(systematicRisk, 2) + Math.pow(specificRisk, 2));
  
  return {
    totalRisk,
    systematicRisk,
    specificRisk,
    factorRisks
  };
}

/**
 * Calculate factor risk contributions
 */
function calculateFactorRiskContributions(
  factorExposures: { [factor: string]: number },
  factorCovarianceMatrix: { [factor: string]: { [factor: string]: number } }
): FactorRisk[] {
  const factors = Object.keys(factorExposures);
  const riskContributions: FactorRisk[] = [];
  
  factors.forEach(factor => {
    const exposure = factorExposures[factor];
    const factorVariance = factorCovarianceMatrix[factor]?.[factor] || 0;
    const volatility = Math.sqrt(factorVariance);
    
    // Risk contribution = exposure × factor volatility
    const contribution = Math.abs(exposure) * volatility;
    
    riskContributions.push({
      factor,
      exposure,
      volatility,
      contribution,
      percentage: 0 // Will be calculated after total risk is known
    });
  });
  
  // Calculate percentages
  const totalContribution = riskContributions.reduce((sum, fr) => sum + fr.contribution, 0);
  riskContributions.forEach(fr => {
    fr.percentage = totalContribution > 0 ? (fr.contribution / totalContribution) * 100 : 0;
  });
  
  return riskContributions;
}

/**
 * Calculate specific (idiosyncratic) risk
 */
function calculateSpecificRisk(
  portfolio: Portfolio,
  specificRisks: { [symbol: string]: number }
): number {
  let totalSpecificRisk = 0;
  
  portfolio.assets.forEach((asset, index) => {
    const weight = portfolio.weights[index];
    const specificRisk = specificRisks[asset.symbol] || 0;
    totalSpecificRisk += Math.pow(weight * specificRisk, 2);
  });
  
  return Math.sqrt(totalSpecificRisk);
}

// ===========================================
// Time-Based Attribution
// ===========================================

/**
 * Calculate attribution over multiple time periods
 */
export function calculateTimeBasedAttribution(
  portfolioReturns: number[],
  benchmarkReturns: number[],
  periods: number[] // Array of period end indices
): Array<{
  period: number;
  portfolioReturn: number;
  benchmarkReturn: number;
  activeReturn: number;
  contribution: number;
}> {
  const results = [];
  let lastIndex = 0;
  
  for (const periodEnd of periods) {
    const portfolioPeriodReturns = portfolioReturns.slice(lastIndex, periodEnd);
    const benchmarkPeriodReturns = benchmarkReturns.slice(lastIndex, periodEnd);
    
    const portfolioReturn = portfolioPeriodReturns.reduce((acc, r) => acc * (1 + r), 1) - 1;
    const benchmarkReturn = benchmarkPeriodReturns.reduce((acc, r) => acc * (1 + r), 1) - 1;
    const activeReturn = portfolioReturn - benchmarkReturn;
    
    // Contribution to total active return (geometric linking)
    const contribution = activeReturn; // Simplified - would need proper geometric attribution
    
    results.push({
      period: periodEnd,
      portfolioReturn,
      benchmarkReturn,
      activeReturn,
      contribution
    });
    
    lastIndex = periodEnd;
  }
  
  return results;
}

// ===========================================
// Helper Functions
// ===========================================

interface SectorData {
  sector: string;
  portfolioWeight: number;
  benchmarkWeight: number;
  portfolioReturn: number;
  benchmarkReturn: number;
}

/**
 * Aggregate portfolio and benchmark data by sector
 */
function aggregateBySector(
  portfolio: Portfolio,
  benchmarkWeights: { [symbol: string]: number },
  benchmarkReturns: { [symbol: string]: number[] },
  sectors: { [symbol: string]: string }
): SectorData[] {
  const sectorMap = new Map<string, {
    portfolioWeight: number;
    benchmarkWeight: number;
    portfolioValue: number;
    benchmarkValue: number;
  }>();
  
  // Aggregate portfolio data
  portfolio.assets.forEach((asset, index) => {
    const sector = sectors[asset.symbol] || 'Other';
    const weight = portfolio.weights[index];
    const assetReturn = calculateAnnualizedReturn(asset.returns);
    
    if (!sectorMap.has(sector)) {
      sectorMap.set(sector, {
        portfolioWeight: 0,
        benchmarkWeight: 0,
        portfolioValue: 0,
        benchmarkValue: 0
      });
    }
    
    const sectorData = sectorMap.get(sector)!;
    sectorData.portfolioWeight += weight;
    sectorData.portfolioValue += weight * assetReturn;
  });
  
  // Aggregate benchmark data
  Object.entries(benchmarkWeights).forEach(([symbol, weight]) => {
    const sector = sectors[symbol] || 'Other';
    const assetReturn = benchmarkReturns[symbol] 
      ? calculateAnnualizedReturn(benchmarkReturns[symbol]) 
      : 0;
    
    if (!sectorMap.has(sector)) {
      sectorMap.set(sector, {
        portfolioWeight: 0,
        benchmarkWeight: 0,
        portfolioValue: 0,
        benchmarkValue: 0
      });
    }
    
    const sectorData = sectorMap.get(sector)!;
    sectorData.benchmarkWeight += weight;
    sectorData.benchmarkValue += weight * assetReturn;
  });
  
  // Convert to array format
  return Array.from(sectorMap.entries()).map(([sector, data]) => ({
    sector,
    portfolioWeight: data.portfolioWeight,
    benchmarkWeight: data.benchmarkWeight,
    portfolioReturn: data.portfolioWeight > 0 ? data.portfolioValue / data.portfolioWeight : 0,
    benchmarkReturn: data.benchmarkWeight > 0 ? data.benchmarkValue / data.benchmarkWeight : 0
  }));
}

/**
 * Calculate tracking error attribution
 */
export function calculateTrackingErrorAttribution(
  portfolioReturns: number[],
  benchmarkReturns: number[],
  windowSize: number = 36
): Array<{
  period: number;
  trackingError: number;
  attribution: {
    allocationRisk: number;
    selectionRisk: number;
    interactionRisk: number;
  };
}> {
  const results = [];
  
  for (let i = windowSize - 1; i < portfolioReturns.length; i++) {
    const portfolioWindow = portfolioReturns.slice(i - windowSize + 1, i + 1);
    const benchmarkWindow = benchmarkReturns.slice(i - windowSize + 1, i + 1);
    
    // Calculate active returns
    const activeReturns = portfolioWindow.map((r, idx) => r - benchmarkWindow[idx]);
    
    // Calculate tracking error (standard deviation of active returns)
    const mean = activeReturns.reduce((sum, r) => sum + r, 0) / activeReturns.length;
    const variance = activeReturns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / (activeReturns.length - 1);
    const trackingError = Math.sqrt(variance * 252); // Annualized
    
    // Risk attribution (simplified)
    results.push({
      period: i,
      trackingError,
      attribution: {
        allocationRisk: trackingError * 0.4, // Simplified allocation
        selectionRisk: trackingError * 0.5,  // Simplified selection
        interactionRisk: trackingError * 0.1 // Simplified interaction
      }
    });
  }
  
  return results;
}